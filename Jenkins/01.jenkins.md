# Introduction to Jenkins & CI/CD

## What is Jenkins?
- Jenkins is an open-source automation server that runs tasks (build, test, deploy).
- Extensible via plugins and works well with Git, Docker, Kubernetes, and artifact registries.
- Use Jenkinsfile (pipeline-as-code) stored in your repo to define pipelines.

## What is CI/CD (easy language)
- CI (Continuous Integration): Every time someone changes code, the system automatically builds and tests it so bugs are found fast.
- CD (Continuous Delivery / Deployment): After tests pass, the same build is prepared to be released. Delivery means ready-to-deploy; Deployment means automatically pushed to production.

## Simple CI/CD diagram 

![DevSecOps+GitOps](https://github.com/user-attachments/assets/5b20eed7-9c07-4671-9d32-12b171ee6708)

---

## Easy explanation of each step
- Developer: writes code and pushes a branch or opens a PR.
- Git/SCM: triggers pipeline on push or PR.
- CI Server (Jenkins): checks out code, builds, and runs quick checks (lint, unit tests).
- Package: creates a versioned artifact or Docker image.
- Artifact Registry: stores the built artifact so deployments use the exact same build.
- CD Pipeline: deploys the artifact to staging, runs integration/E2E tests.
- Gate/Approval: automated policies or manual approval before production.
- Production: deploys the tested artifact to users.
- Monitoring: watches app health; sends feedback to developers.

## Why CI/CD matters (short)
- Faster feedback, fewer integration surprises.
- Safer releases via small, tested changes.
- Repeatable deployments using the same artifact.

## Quick Jenkins best practices
- Keep pipeline-as-code (Jenkinsfile) in each repo.
- Use agents/containers for consistent build environments.
- Run fast checks first (lint, unit tests) to fail fast.
- Store secrets in Jenkins credentials store.
- Use multibranch pipelines for branch/PR isolation.

## Minimal example Jenkinsfile (concept)
```groovy
pipeline {
  agent any
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build')    { steps { sh 'make build' } }
    stage('Test')     { steps { sh 'make test' } }
    stage('Package')  { steps { sh 'make package && docker build -t myapp:$BUILD_NUMBER .' } }
  }
  post { always { archiveArtifacts artifacts: 'build/**', fingerprint: true } }
}
```
