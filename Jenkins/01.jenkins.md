# Introduction to Jenkins & CI/CD

## What is Jenkins?
- Jenkins is an open-source automation server that runs tasks (build, test, deploy).
- Extensible via plugins and works well with Git, Docker, Kubernetes, and artifact registries.
- Use Jenkinsfile (pipeline-as-code) stored in your repo to define pipelines.

## What is CI/CD (easy language)
- CI (Continuous Integration): Every time someone changes code, the system automatically builds and tests it so bugs are found fast.
- CD (Continuous Delivery / Deployment): After tests pass, the same build is prepared to be released. Delivery means ready-to-deploy; Deployment means automatically pushed to production.

## Simple CI/CD diagram (Mermaid)
```mermaid
graph LR
  Dev[Developer\n(branch / PR)] -->|push| SCM[Git / SCM]
  SCM --> CI[CI Server\n(Jenkins)]
  CI --> Build[Checkout + Build]
  CI --> Unit[Unit Tests + Lint]
  Build --> Package[Package / Docker Image]
  Package --> Registry[Artifact Registry]
  Registry --> CD[CD Pipeline]
  CD --> Staging[Deploy -> Staging / QA]
  Staging --> E2E[E2E / Integration Tests]
  E2E --> Gate{Pass & Policy}
  Gate -->|approve| Prod[Deploy -> Production]
  Prod --> Monitor[Monitoring & Alerts]
  Monitor --> Feedback[Issue / PR created]
```

ASCII fallback:
Developer -> Git/SCM -> CI (build + tests) -> Registry -> CD -> Staging (tests) -> Approval -> Production -> Monitoring -> Feedback

## Easy explanation of each step
- Developer: writes code and pushes a branch or opens a PR.
- Git/SCM: triggers pipeline on push or PR.
- CI Server (Jenkins): checks out code, builds, and runs quick checks (lint, unit tests).
- Package: creates a versioned artifact or Docker image.
- Artifact Registry: stores the built artifact so deployments use the exact same build.
- CD Pipeline: deploys the artifact to staging, runs integration/E2E tests.
- Gate/Approval: automated policies or manual approval before production.
- Production: deploys the tested artifact to users.
- Monitoring: watches app health; sends feedback to developers.

## Why CI/CD matters (short)
- Faster feedback, fewer integration surprises.
- Safer releases via small, tested changes.
- Repeatable deployments using the same artifact.

## Quick Jenkins best practices
- Keep pipeline-as-code (Jenkinsfile) in each repo.
- Use agents/containers for consistent build environments.
- Run fast checks first (lint, unit tests) to fail fast.
- Store secrets in Jenkins credentials store.
- Use multibranch pipelines for branch/PR isolation.

## Minimal example Jenkinsfile (concept)
```groovy
pipeline {
  agent any
  stages {
    stage('Checkout') { steps { checkout scm } }
    stage('Build')    { steps { sh 'make build' } }
    stage('Test')     { steps { sh 'make test' } }
    stage('Package')  { steps { sh 'make package && docker build -t myapp:$BUILD_NUMBER .' } }
  }
  post { always { archiveArtifacts artifacts: 'build/**', fingerprint: true } }
}
```
